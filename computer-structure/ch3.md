# 명령어
## 소스 코드와 명령어
### 고급언어와 저급언어
- 고급언어: 사람이 이해하고 작성하기 쉽게 만들어진 언어, 대부분의 프로그래밍 언어
- 저급언어: 컴퓨터가 직접 이해하고 실행할 수 있는 언어
  - 명령어로 구성되어있음
- 컴퓨터가 이해하고 실행할 수 있는 언어는 오직 `저급 언어` 뿐이다.

저급 언어에는 두 가지 종류가 있다.
- 기계어
- 어셈블리어

`기계어`는 0과 1의 명령어 비트로 이루어진 언어이다. 기계어는 오로지 컴퓨터만을 위해 만들어진 언어이기 때문에 사람이 이해하기 어렵다. <br>
`어셈블리어`는 0과 1로 표현된 명령어(기계어)를 읽기 편한 형태로 번역한 언어이다.

### 컴파일 언어와 인터프리터 언어
개발자들이 고급 언어로 작성한 코드는 결국 저급 언어로 변환되어 실행된다. 그렇다면 어떻게 변환되는 것일까?

변환되는 방법에는 두 가지 방법이 있다.
- `컴파일 방식`
- `인터프리터 방식`

컴파일 방식으로 작동하는 프로그래밍 언어를 `컴파일 언어`, 인터프리터 방식으로 작동하는 프로그래밍 언어를 `인터프리터 언어`라고 한다.

#### 컴파일 언어
`컴파일 언어`는 컴파일러에 의해 소스 코드 전체가 저급 언어로 변환되어 실행되는 고급 언어이다. <br>
컴파일 언어로 작성된 코드를 저급 언어로 변환되는 과정을 `컴파일`이라고 한다. 이때 컴파일을 수행하는 도구를 `컴파일러`라고 한다. 

컴파일러가 코드 전체를 훑어보며 문법적인 오류는 없는지, 실행이 가능한지, 불필요한 코드는 없는지 등을 따지면서 코드 처음부터 끝까지 저급 언어로 컴파일 한다. 이때 오류가 하나라도 발견되면 소스코드는 컴파일에 실패하게 된다.

컴파일이 성공적으로 수행되면 코드는 저급언어로 변환되는데 이 변환된 코드를 `목적 코드`라고 한다.

#### 인터프리터 언어
`인터프리터 언어`는 인터프리터에 의해 코드가 한 줄씩 실행되는 고급 언어이다.<br>
인터프리터 언어는 소스 코드를 한줄씩 차례로 실행한다. 이때 소스코드를 한줄 씩 저급 언어로 변환하여 실행해주는 도구를 `인터프리터` 라고 한다.

한줄씩 실행되기 때문에 코드 전체를 변환하는 시간을 기다릴 필요가 없다.

인터프리터 언어는 코드를 한 줄씩 실행하기 때문에 N번째에 오류가 있다 하더라도 N-1번째 줄까지 올바르게 실행된다.

일반적으로 인터프리터 언어가 컴파일 언어보다 느리다. 목적 코드는 컴퓨터가 이해하고 실행할 수 있는 반면, 인터프리터 언어는 마지막에 도달할 때까지 한 줄씩 해석하며 실행해야하기 때문이다.

## 명령어의 구조
### 연산 코드와 오퍼랜드
명령어는 연산코드와 오퍼랜드로 구성
- 연산코드: 명령어가 수행할 연산, 연산자
- 오퍼랜드: 연산에 사용할 데이터가 저장된 위치, 피연산자

연산 코드가 담긴 영역을 `연산 코드 필드`, 오퍼랜드가 담기는 영역을 `오퍼랜드 필드`라 한다.

#### 오퍼랜드
`오퍼랜드 필드`에는 데이터 또는 메모리나 레지스터 주소가 올 수 있다. 숫자나 문자 같이 연산에 사용할 데이터를 직접 명시하기보다는 데이터가 저장된 위치인 `메모리 주소`나 `레지스터 이름`이 담긴다. 그래서 `주소 필드`라고도 한다.

오퍼랜드는 명령어 안에 하나도 없을 수도, 한 개만 있을 수도, 여러 개 있을 수도 있다.
- 0-주소 명령어: 오퍼랜드가 `하나도 없는` 명령어
- 1-주소 명령어: 오퍼랜드가 `하나`인 명령어
- 2-주소 명령어: 오퍼랜드가 `두 개`인 명령어
- 3-주소 명령어: 오퍼랜드가 `세 개`인 명령어

#### 연산 코드
가장 기본적인 연산 코드 유형은 크게 네 가지로 나눌 수 있다.
- 데이터 전송
- 산술/논리 연산
- 제어 흐름 변경
- 입출력 제어

### 주소 지정 방식
이전에 오퍼랜드 필드에 메모리나 레지스터 주소를 담는 경우가 많다고 했다. <br>
그런데 그냥 <연산코드, 데이터> 형식으로 명령어를 구성되면 될 것을 오퍼랜드 필드에 메모리나 레지스터 주소를 담는 것인가?
이는 명령어의 길이 때문에 그렇다. <br>

하나의 예시를 들어보자

하나의 명령어가 n비트로 구성되어있고, 그중 연산 코드 필드가 m비트라 가정하자.<br>
오퍼랜드 필드에 가장 많은 공간을 할당할 수 있는 1-주소 명령어라 할 지라도 오퍼랜드 필드 길이는 연산 코드 필드 길이를 뺀 n-m비트가 된다. 2-주소 명령어, 3-주소 명령어라면 오퍼랜드 필드 크기는 더욱 작아질 것이다.

하지만 오퍼랜드 필드 안에 메모리 주소가 담긴다면 표현할 수 있는 데이터의 크기는 하나의 메모리 주소에 저장할 수 있는 공간만큼 커진다.

예를 들어,<br>
한 주소에 16비트를 저장할 수 있는 메모리가 있다고 가정하자. 이 메모리 안에 데이터를 저장하고 오퍼랜드 필드 안에 해당 메모리 주소를 명시한다면 표현할 수 있는 정보 가짓수가 2^16으로 커지게 된다.

오퍼랜드 필드에 레지스터 이름을 명시할 때도 마찬가지다. 이 경우 표현할 수 있는 정보 가짓수는 레지스터가 저장할 수 있는 공간만큼 커진다.

`유효 주소`: 연산 코드에 사용할 데이터가 저장된 위치, 연산의 대상이 되는 데이터가 저장된 위치<br>
`주소 지정 방식`: 필드에 데이터가 저장된 위치를 명시할 때 연산에 사용할 데이터 위치를 찾는 방법<br>

대표적인 주소 지정 방식 다섯가지를 알아보자.
#### 즉시 주소 지정 방식
`즉시 주소 지정 방식`: 연산에 사용할 데이터를 오퍼랜드 필드에 직접 명시하는 방식
- 표현할 수 있는 데이터의 크기가 작아진다.
- 연산에 사용할 데이터를 메모리나 레지스터로부터 찾는 과정이 없기 때문에 다른 주소 지정 방식들 보다 빠르다.

#### 직접 주소 지정 방식
`직접 주소 지정 방식`: 오퍼랜드 필드에 유효 주소를 직접적으로 명시하는 방식
- 즉지 주소 지정 방식보다 표현할 수 있는 데이터의 크기가 크다.
- 표현할 수 있는 오퍼랜드 필드 길이가 연산 코드의 길이만큼 짧아져 표현할 수 있는 유효 주소에 제한이 생길 수 있음

#### 간접 주소 지정 방식
`간접 주소 지정 방식`: 유효 주소의 주소를 오퍼랜드 필드에 명시하는 방식
- 직접 주소 지정 방식보다 표현할 수 있는 유효 주소의 범위가 더 넓어짐
- 하지만 두 번의 메모리 접근이 필요하기 대문에 위에 설명한 주소 지정 방식보다 일반적으로 느리다.

#### 레지스터 주소 지정 방식
`레지스터 주소 지정 방식`: 연산에 사용할 데이터를 저장한 레지스터를 오퍼랜드 필드에 직접 명시하는 방식
- CPU 외부에 있는 메모리에 접근하는 것보단 CPU 내부에 있는 레지스터에 접근하는 것이 더 빠르다.
- 직접 주소 지정 방식보다 빠르게 데이터에 접근할 수 있음
- 표현할 수 있는 레지스터 크기에 제한이 생길 수 있다.

#### 레지스터 간접 주소 지정 방식
`레지스터 간접 주소 지정 방식`: 연산에 사용할 데이터를 메모리에 저장하고 그 주소(유효 주소)를 저장한 레지스터를 오퍼랜드 필드에 명시하는 방법

간접 주소 지정 방식과 비슷하지만 메모리에 접근하는 횟수가 한 번으로 줄어든다.

**오퍼랜드 필드에 명시하는 값 정리** <br>
- 즉시 주소 지정 방식: 연산에 사용할 데이터
- 직접 주소 지정 방식: 유효 주소(메모리 주소)
- 간접 주소 지정 방식: 유효 주소의 주소
- 레지스터 주소 지정 방식: 유효 주소(레지스터 이름)
- 레시스터 간접 주소 지정 방식: 유효 주소를 지정한 래지스터

