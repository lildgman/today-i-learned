# 최단경로 알고리즘
- 가장 짧은 경로를 찾는 알고리즘
- 여러 문제 상황이 주어질 수 있다
  - 한 지점에서 다른 한 지점까지의 최단 경로
  - 한 지점에서 다른 모든 지점까지의 최단 경로
  - 모든 지점에서 다른 모든 지점까지의 최단 경로
- 각 지점은 그래프에서 **노드**로 표현
- 지점 간 연결된 도로는 그래프에서 **간선**으로 표현

## 다익스트라 최단 경로 알고리즘
- **특정 노드**에서 출발해 **다른 모든 노드**로 가는 최단 경로를 계산한다.
- 음의 간선이 없을 때 정상적으로 동작한다.
  - 현실 세계에서의 도로는 음의 간선으로 표현되지 않기 때문이다.
- 그리고 그리디 알고리즘으로 분류된다.
  - **매 상황에서 가장 비용이 적은 노드를 선택**해 임의의 과정은 반복한다.
  - 기본적으로 최단경로 문제는 다이나믹 프로그래밍 알고리즘으로 분류된다.

### 동작과정
1. 출발 노드 설정
2. 최단 거리 테이블 초기화 
  - 모든 노드까지 거리를 무한으로 설정
  - 자기 자신에 대한 노드는 0으로 설정
3. 방문하지 않은 노드 중에서 최단 거리가 가장 짧은 노드를 선택
4. 해당 노드를 거쳐 다른 노드로 가는 비용을 계산하여 최단 거리 테이블을 갱신
5. 3번, 4번을 반복

![alt text](image.png)

![alt text](image-3.png)

1번 노드를 통해 이동할 수 있는 노드는 2번, 3번, 4번 노드이다. 테이블 정보를 확인해보면 2번, 3번, 4번까지 이동하기 위한 거리는 모두 무한대이다.

이제 1번을 거쳐서 이동하게 되면 2번은 0+2, 3번은 0+3, 4번은 0+1이 되고 무한대보다 작으므로 최단거리값을 2번은 2, 3번은 3, 4번은 1로 변경해준다.

![alt text](image-4.png)

4번 노드를 통해 이동할 수 있는 노드는 3번, 5번 노드이다. 3번으로 이동하기 위한 비용은 3, 5번으로 이동하기 위한 비용은 1이다. 

이때 4번까지 이동하기 위한 비용은 1로 변경되지 않는다. 이전까지 3번까지의 최단거리가 5라고 담겨있었는데 이제 4번을 거쳐가는 비용인 1+3=4가 최단거리이므로 4를 최단거리로 갱신해준다.

5번의 최단거리는 무한대였는데 4번을 거쳐갈때의 경우를 확인해 1+1를 최단경우로 갱신해준다.

![alt text](image-5.png)

2번 노드를 통해 이동할 수 있는 노드는 3번과 4번이다. 3번의 최단거리는 4이다. 2번을 거쳐갈 때의 비용은 5이므로 최단거리는 갱신되지 않는다. 4번의 최단거리는 1이다. 2번을 거쳐갈 때의 비용은 2이므로 최단거리는 갱신되지 않는다. 

![alt text](image-6.png)

5번 노드를 통해 이동할 수 있는 노드는 3번과 6번이다. 3번의 최단거리는 4이다. 5번을 거쳐갈 때의 비용은 2+1=3이다. 4보다 작으므로 최단거리를 3으로 갱신한다.
6번의 최단거리는 현재 무한대이므로 5번을 거쳐갈 때의 비용인 2+2인 4를 최단거리로 갱신한다.

![alt text](image-7.png)

3번 노드를 통해 이동할 수 있는 노드는 2번과 6번이다. 2번의 최단거리는 2이다. 3번을 거쳐갈 때의 비용은 3+3이므로 현재 최단거리보다 크므로 최단거리를 갱신하지 않는다.

6번의 최단거리는 4이다. 3번을 거쳐갈 때의 비용은 3+5이다. 현재 최단거리보다 크므로 최단거리를 갱신하지 않는다.

![alt text](image-8.png)

6번에서 출발하고자 하는 노드가 없으므로 종료

### 다익스트라 알고리즘 특징
- 그리디 알고리즈: **매 상황에서 방문하지 않은 가장 비용이 적은 노드를 선택**해 임의의 과정 반복
- 단계를 거치며 **한 번 처리된 노드의 최단 거리는 고정**
  - 한 단계당 하나의 노드에 대한 최단 거리를 확실히 찾는 것으로 이해하자
- 다익스트라 알고리즘 수행 후 테이블에 각 노드까지 최단 거리 정보가 저장되어야 한다.
  - 완벽한 형태의 최단 경로를 구하려면 소스코드에 추가적인 기능을 더 넣어야 함
